"""Error correction module for post-processing OCR results.

This module applies corrections to OCR text results using a static dictionary
of common recognition errors. It processes JSON files generated by the OCR engine
and outputs enhanced results with correction metadata.
"""

from __future__ import annotations

import json
import logging
import time
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, List, Optional

from config.corrections import get_correction
from config.settings import Settings


@dataclass(frozen=True)
class CorrectionResult:
    """Result information returned by the error corrector."""
    
    output_path: Path
    duration_seconds: float
    total_texts: int
    corrections_applied: int
    correction_rate: float


class ErrorCorrector:
    """Post-processor for correcting common OCR recognition errors."""

    def __init__(self, settings: Settings, logger: logging.Logger) -> None:
        self._settings = settings
        self._logger = logger

    def process(self, input_path: Path, output_path: Optional[Path] = None) -> CorrectionResult:
        """Apply error corrections to OCR results JSON file.
        
        Args:
            input_path: Path to OCR results JSON file (-texts.json)
            output_path: Optional custom output path for corrected results
            
        Returns:
            CorrectionResult with processing metrics
        """
        start_time = time.perf_counter()
        
        # Load OCR results
        ocr_data = self._load_ocr_results(input_path)
        
        # Apply corrections to text regions
        corrected_data, corrections_log = self._apply_corrections(ocr_data)
        
        # Create output structure
        output_data = self._create_output_structure(
            ocr_data, corrected_data, corrections_log, start_time
        )
        
        # Save to JSON
        destination = output_path or self._build_output_path(input_path)
        destination.parent.mkdir(parents=True, exist_ok=True)
        
        with open(destination, 'w', encoding='utf-8') as f:
            json.dump(output_data, f, ensure_ascii=False, indent=2)
        
        duration = time.perf_counter() - start_time
        
        total_texts = len(ocr_data.get("text_regions", []))
        corrections_count = len(corrections_log)
        correction_rate = corrections_count / total_texts if total_texts > 0 else 0.0
        
        self._logger.info(
            "Error correction completed in %.3f seconds. Applied %d corrections to %d texts (%.1f%%)",
            duration, corrections_count, total_texts, correction_rate * 100
        )
        
        return CorrectionResult(
            output_path=destination,
            duration_seconds=duration,
            total_texts=total_texts,
            corrections_applied=corrections_count,
            correction_rate=correction_rate
        )

    def _load_ocr_results(self, path: Path) -> Dict[str, Any]:
        """Load OCR results from JSON file."""
        if not path.exists():
            raise FileNotFoundError(f"OCR results file '{path}' does not exist")
        
        with open(path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        self._logger.debug("Loaded OCR results from '%s'", path)
        return data

    def _apply_corrections(self, ocr_data: Dict[str, Any]) -> tuple[Dict[str, Any], List[Dict[str, Any]]]:
        """Apply corrections to text regions in OCR data.
        
        Args:
            ocr_data: Original OCR results dictionary
            
        Returns:
            Tuple of (corrected_data, corrections_log)
        """
        corrected_data = ocr_data.copy()
        corrections_log = []
        
        text_regions = ocr_data.get("text_regions", [])
        corrected_regions = []
        
        for idx, region in enumerate(text_regions):
            original_text = region.get("text", "")
            corrected_text, was_corrected = get_correction(original_text)
            
            # Create corrected region with additional metadata
            corrected_region = region.copy()
            corrected_region["text"] = corrected_text
            corrected_region["corrected"] = was_corrected
            
            if was_corrected:
                corrected_region["original_text"] = original_text
                
                # Log the correction
                corrections_log.append({
                    "index": idx,
                    "field": f"text_region_{idx}",
                    "original": original_text,
                    "corrected": corrected_text,
                    "confidence": region.get("confidence", 0.0),
                    "position": region.get("center", [0, 0])
                })
                
                self._logger.debug(
                    "Correction applied at index %d: '%s' -> '%s'",
                    idx, original_text, corrected_text
                )
            else:
                corrected_region["original_text"] = None
            
            corrected_regions.append(corrected_region)
        
        corrected_data["text_regions"] = corrected_regions
        
        return corrected_data, corrections_log

    def _create_output_structure(
        self,
        original_data: Dict[str, Any],
        corrected_data: Dict[str, Any],
        corrections_log: List[Dict[str, Any]],
        start_time: float
    ) -> Dict[str, Any]:
        """Create output JSON structure with correction metadata.
        
        Args:
            original_data: Original OCR results
            corrected_data: OCR results with corrections applied
            corrections_log: List of corrections that were applied
            start_time: Processing start time
            
        Returns:
            Complete output structure with all metadata
        """
        duration = time.perf_counter() - start_time
        
        # Get original metrics
        original_metrics = original_data.get("processing_metrics", {})
        
        # Build output structure
        output = {
            "document_info": original_data.get("document_info", {}),
            "text_regions": corrected_data.get("text_regions", []),
            "corrections_applied": {
                "count": len(corrections_log),
                "corrections": corrections_log
            },
            "processing_metrics": {
                # Original OCR metrics
                "ocr_time_ms": original_metrics.get("total_time_ms", 0),
                "texts_detected": original_metrics.get("texts_detected", 0),
                "average_confidence": original_metrics.get("average_confidence", 0.0),
                
                # Correction metrics
                "correction_time_ms": int(duration * 1000),
                "corrections_applied": len(corrections_log),
                "correction_rate": len(corrections_log) / len(corrected_data.get("text_regions", [])) if corrected_data.get("text_regions") else 0.0,
                
                # Combined metrics
                "total_time_ms": original_metrics.get("total_time_ms", 0) + int(duration * 1000)
            }
        }
        
        return output

    def _build_output_path(self, input_path: Path) -> Path:
        """Generate output path with -corrected suffix.
        
        Args:
            input_path: Input OCR results file path
            
        Returns:
            Output path for corrected results
        """
        output_dir = self._settings.output_dir
        output_dir.mkdir(parents=True, exist_ok=True)
        
        stem = input_path.stem
        # Remove existing -texts suffix if present
        if stem.endswith('-texts'):
            stem = stem[:-6]
        
        filename = f"{stem}-corrected.json"
        return output_dir / filename

